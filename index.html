<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tjatur Djawa Remastered</title>
<link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700;900&display=swap" rel="stylesheet">

<style>
/* --- RESET & BASE --- */
* { box-sizing: border-box; user-select: none; -webkit-user-select: none; }
body {
  margin: 0;
  min-height: 100vh;
  background-color: #1e1e1e; /* Dark Background */
  color: #e0e0e0;
  font-family: 'Nunito', sans-serif;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

/* --- HEADER --- */
h1 {
  margin: 0 0 20px 0;
  font-size: 42px;
  font-weight: 900;
  letter-spacing: 1px;
}
.title-white { color: #ffffff; }
.title-green { color: #7da646; }

/* --- CONTROLS (Top Panel) --- */
.control-panel {
  display: flex;
  gap: 12px;
  margin-bottom: 25px;
  width: 100%;
  max-width: 420px;
  justify-content: center;
}

/* Styling Dropdown agar mirip tombol hijau */
.custom-select-wrapper {
  position: relative;
  background-color: #7da646; /* Green */
  border-radius: 6px;
  overflow: hidden;
  box-shadow: 0 4px 0 #5a7d2e;
  transition: transform 0.1s;
}
.custom-select-wrapper:active {
  transform: translateY(4px);
  box-shadow: 0 0 0 #5a7d2e;
}
select {
  appearance: none;
  background: transparent;
  border: none;
  color: white;
  padding: 12px 20px;
  font-family: 'Nunito', sans-serif;
  font-weight: 700;
  font-size: 16px;
  cursor: pointer;
  padding-right: 35px; /* Space for arrow */
}
/* Custom Arrow for select */
.custom-select-wrapper::after {
  content: 'â–¼';
  font-size: 10px;
  color: white;
  position: absolute;
  right: 12px;
  top: 50%;
  transform: translateY(-50%);
  pointer-events: none;
}

/* Reset Button */
.btn-reset {
  background-color: #616161; /* Grey */
  color: white;
  border: none;
  border-radius: 6px;
  padding: 12px 20px;
  font-family: 'Nunito', sans-serif;
  font-weight: 700;
  font-size: 16px;
  cursor: pointer;
  box-shadow: 0 4px 0 #424242;
  transition: transform 0.1s;
}
.btn-reset:hover { filter: brightness(1.1); }
.btn-reset:active {
  transform: translateY(4px);
  box-shadow: 0 0 0 #424242;
}

/* --- TURN INDICATOR --- */
#turn-indicator {
  margin-bottom: 20px;
  padding: 6px 20px;
  border: 2px solid #7da646;
  border-radius: 20px;
  font-weight: 800;
  font-size: 14px;
  letter-spacing: 1px;
  text-transform: uppercase;
  color: #fff;
  background: rgba(125, 166, 70, 0.1);
}

/* --- GAME BOARD CONTAINER --- */
.game-container {
  background-color: #2b2b2b;
  border-radius: 16px;
  padding: 20px;
  box-shadow: 0 10px 30px rgba(0,0,0,0.5);
  width: 420px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

/* --- PLAYER INFO BARS --- */
.player-info {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0 5px;
}
.player-name {
  display: flex;
  align-items: center;
  gap: 8px;
  font-weight: 700;
  font-size: 16px;
}
.icon { font-size: 20px; }

.timer-box {
  padding: 6px 12px;
  border-radius: 4px;
  font-family: 'Courier New', monospace; /* Monospaced for numbers */
  font-weight: bold;
  font-size: 16px;
  min-width: 70px;
  text-align: center;
}
/* Computer Timer (Top) - Greyish */
.timer-top { background-color: #9e9e9e; color: #222; }
/* Player Timer (Bottom) - Dark */
.timer-bot { background-color: #1a1a1a; color: #fff; border: 1px solid #444; }

/* --- CANVAS --- */
canvas {
  display: block;
  margin: 10px auto;
  border-radius: 4px;
  cursor: pointer;
  /* background handled in JS draw */
}

/* --- FOOTER --- */
.footer {
  margin-top: 30px;
  font-size: 12px;
  color: #666;
  font-weight: 600;
}
</style>
</head>
<body>

<h1><span class="title-white">Tjatur</span><span class="title-green">Djawa</span></h1>

<div class="control-panel">
  <div class="custom-select-wrapper">
    <select id="mode">
      <option value="2P">2 Player</option>
      <option value="EASY">Easy (AI)</option>
      <option value="MEDIUM">Medium (AI)</option>
      <option value="HARD">Hard (AI)</option>
      <option value="AI-VS-AI">AI vs AI</option>
    </select>
  </div>
  <button class="btn-reset" onclick="fullReset()">Reset Board</button>
</div>

<div id="turn-indicator">WHITE TURN</div>

<div class="game-container">
  
  <div class="player-info">
    <div class="player-name">
      <span class="icon">ðŸ¤–</span> Computer
    </div>
    <div class="timer-box timer-top" id="timer-black">10:00</div>
  </div>

  <canvas id="game" width="380" height="380"></canvas>

  <div class="player-info">
    <div class="player-name">
      <span class="icon">ðŸ¤“</span> Player
    </div>
    <div class="timer-box timer-bot" id="timer-white">10:00</div>
  </div>

</div>

<div class="footer">TjaturDjawa build 2.203.0MX â€¢ Nidroverse Corp. Â©2026</div>

<script>
/* ================= CONFIGURATION & ASSETS ================= */
const c = document.getElementById("game");
const ctx = c.getContext("2d");

// Load Textures from User Request
const imgWhite = new Image(); imgWhite.src = "https://i.imgur.com/1PGrkTJ.png"; // Direct link extracted
const imgBlack = new Image(); imgBlack.src = "https://i.imgur.com/FFs4pZc.png"; // Direct link extracted
// Fallback textures just in case images fail to load or blocked
const fallbackWhite = "â™Ÿ"; 
const fallbackBlack = "â™Ÿ";

// Colors (Pixel Perfect extraction)
const COLOR_BG = "#2b2b2b";
const COLOR_TILE_LIGHT = "#f2dcb3"; // Cream
const COLOR_TILE_DARK = "#b08566";  // Brown
const COLOR_LINE = "#8d6e63";       // Line connecting tiles
const COLOR_HIGHLIGHT = "rgba(255, 255, 0, 0.4)"; // Gold glow for movement
const COLOR_WIN_GLOW = "rgba(57, 255, 20, 0.6)"; // Green neon for win
const COLOR_LINE_WIN = "#39ff14";
const COLOR_LINE_MOVE = "#ffd700";

// Grid System (Mapping 0-8 to X,Y coordinates on 380x380 canvas)
// Layout 3x3. Tile size approx 90px. Spacing calculated.
const OFFSET = 70; // Padding from edge
const SPACING = 120; // Distance between centers
const N = [];
for(let r=0; r<3; r++){
  for(let c=0; c<3; c++){
    N.push({ x: OFFSET + c*SPACING, y: OFFSET + r*SPACING });
  }
}

// Logic Connections & Wins
const L = [[0,1],[1,2],[3,4],[4,5],[6,7],[7,8],[0,3],[3,6],[1,4],[4,7],[2,5],[5,8],[0,4],[2,4],[6,4],[8,4]];
const W = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];

/* ================= GAME STATE ================= */
let board = Array(9).fill(null);
let turn = "BLUE"; // BLUE = WHITE PLAYER, RED = BLACK PLAYER
let sel = null;
let mode = "2P";
let gameActive = true;
let winningLine = null; // Stores indices of winning line for glow effect
let lastMove = null;    // Stores {from, to} for yellow glow

// Timer State
let timeWhite = 600; // 10 minutes in seconds
let timeBlack = 600;
let timerInterval = null;

// Animation State
let animState = { active: false, fromIdx: -1, toIdx: -1, progress: 0, player: null };

/* ================= AUDIO ================= */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playMoveSound() {
  if (audioCtx.state === 'suspended') audioCtx.resume();
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  // Sound: Wood click "Thock" style
  osc.type = "triangle";
  osc.frequency.setValueAtTime(300, audioCtx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.1);
  gain.gain.setValueAtTime(0.8, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + 0.15);
}

/* ================= CORE FUNCTIONS ================= */

function fullReset(){
  board = Array(9).fill(null);
  // Initial Setup: 3 White bottom, 3 Black top
  board[0]=board[1]=board[2]="RED"; // Computer/Top
  board[6]=board[7]=board[8]="BLUE"; // Player/Bottom
  
  turn = "BLUE"; 
  sel = null; 
  gameActive = true;
  winningLine = null;
  lastMove = null;
  animState.active = false;
  
  // Reset Timers
  clearInterval(timerInterval);
  timeWhite = 600;
  timeBlack = 600;
  updateTimerDisplay();
  timerInterval = setInterval(gameTimerTick, 1000);

  updateTurnUI();
  draw();

  if(mode === "AI-VS-AI") setTimeout(aiMove, 1000);
}

// Timer Logic
function gameTimerTick(){
  if(!gameActive) return;
  
  if(turn === "BLUE") {
    timeWhite--;
    if(timeWhite <= 0) triggerTimeLoss("WHITE");
  } else {
    timeBlack--;
    if(timeBlack <= 0) triggerTimeLoss("BLACK");
  }
  updateTimerDisplay();
}

function updateTimerDisplay(){
  const fmt = (t) => {
    let m = Math.floor(t/60);
    let s = t%60;
    return `${m}:${s<10?'0'+s:s}`;
  };
  document.getElementById("timer-white").innerText = fmt(timeWhite);
  document.getElementById("timer-black").innerText = fmt(timeBlack);
}

function triggerTimeLoss(playerColor){
  gameActive = false;
  clearInterval(timerInterval);
  alert("TIME'S UP! " + (playerColor==="WHITE" ? "BLACK" : "WHITE") + " WINS!");
}

document.getElementById("mode").onchange = (e) => {
  mode = e.target.value;
  fullReset();
};

/* ================= RENDERING (THE REMASTER) ================= */

function draw(){
  // 1. Clear & Background
  ctx.clearRect(0,0,380,380);
  
  // 2. Draw Lines (Connections)
  ctx.lineWidth = 8;
  ctx.lineCap = "round";
  
  L.forEach(l => {
    const isWinLine = winningLine && winningLine.includes(l[0]) && winningLine.includes(l[1]);
    const isMoveLine = lastMove && ((lastMove.from===l[0] && lastMove.to===l[1]) || (lastMove.from===l[1] && lastMove.to===l[0]));
    
    ctx.beginPath();
    ctx.moveTo(N[l[0]].x, N[l[0]].y);
    ctx.lineTo(N[l[1]].x, N[l[1]].y);
    
    if(isWinLine){
      ctx.strokeStyle = COLOR_LINE_WIN;
      ctx.shadowColor = COLOR_LINE_WIN;
      ctx.shadowBlur = 15;
    } else if (isMoveLine){
      ctx.strokeStyle = COLOR_LINE_MOVE;
      ctx.shadowColor = COLOR_LINE_MOVE;
      ctx.shadowBlur = 10;
    } else {
      ctx.strokeStyle = "#4e3b31"; // Darker brown for lines
      ctx.shadowBlur = 0;
    }
    ctx.stroke();
    ctx.shadowBlur = 0; // Reset
  });

  // 3. Draw Tiles (Squares)
  // Pattern: 0,2,4,6,8 = Light; 1,3,5,7 = Dark
  const rectSize = 70; // Size of the square tile
  
  N.forEach((n, i) => {
    let isLight = [0,2,4,6,8].includes(i);
    let tileColor = isLight ? COLOR_TILE_LIGHT : COLOR_TILE_DARK;
    
    // Highlight Logic
    let isSelected = (sel === i);
    let isLastMove = lastMove && (lastMove.from === i || lastMove.to === i);
    let isWinTile = winningLine && winningLine.includes(i);
    
    // Draw Shadow for Depth
    ctx.fillStyle = "rgba(0,0,0,0.5)";
    ctx.fillRect(n.x - rectSize/2 + 4, n.y - rectSize/2 + 4, rectSize, rectSize);

    // Draw Tile Base
    ctx.fillStyle = tileColor;
    
    if(isWinTile){
      ctx.shadowColor = "#39ff14";
      ctx.shadowBlur = 20;
      ctx.fillStyle = "#fff"; // Make tile bright on win
    } else if(isSelected){
      ctx.fillStyle = "#fffacd"; // Highlight selected
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 3;
    } else if(isLastMove){
       // Subtle gold tint
       ctx.shadowColor = "gold";
       ctx.shadowBlur = 15;
    }
    
    ctx.fillRect(n.x - rectSize/2, n.y - rectSize/2, rectSize, rectSize);
    ctx.shadowBlur = 0; // Reset
    
    // Draw Selection Border
    if(isSelected || isWinTile){
      ctx.strokeStyle = isWinTile ? "#39ff14" : "#fff";
      ctx.lineWidth = isWinTile ? 4 : 2;
      ctx.strokeRect(n.x - rectSize/2, n.y - rectSize/2, rectSize, rectSize);
    }

    // 4. Draw Possible Move Indicators (Dots)
    if(sel !== null && valid(sel, i)){
       ctx.beginPath();
       ctx.arc(n.x, n.y, 8, 0, Math.PI*2);
       ctx.fillStyle = "rgba(0,0,0,0.3)";
       ctx.fill();
    }
  });

  // 5. Draw Pieces
  N.forEach((n, i) => {
    // Skip if currently animating this specific piece
    if(animState.active && animState.toIdx === i) return; 
    
    if(board[i]) {
      drawPawn(n.x, n.y, board[i]);
    }
  });

  // 6. Draw Animation
  if(animState.active){
    const startPos = N[animState.fromIdx];
    const endPos = N[animState.toIdx];
    const curX = startPos.x + (endPos.x - startPos.x) * animState.progress;
    const curY = startPos.y + (endPos.y - startPos.y) * animState.progress;
    
    drawPawn(curX, curY, animState.player);
    
    animState.progress += 0.15; // Animation speed
    if(animState.progress < 1) {
      requestAnimationFrame(draw); 
    } else { 
      animState.active = false; 
      draw(); 
    }
  }
}

function drawPawn(x, y, type){
  const size = 50; // Image size
  const offset = size / 2;
  
  if(type === "BLUE"){ // WHITE PLAYER
    if(imgWhite.complete && imgWhite.naturalHeight !== 0){
      // Shadow
      ctx.shadowColor = "rgba(0,0,0,0.5)"; ctx.shadowBlur = 5; ctx.shadowOffsetY = 3;
      ctx.drawImage(imgWhite, x - offset, y - offset - 5, size, size); // -5 for slight levitation
      ctx.shadowBlur = 0; ctx.shadowOffsetY = 0;
    } else {
      // Fallback
      ctx.font = "50px Arial"; ctx.textAlign="center"; ctx.textBaseline="middle";
      ctx.fillStyle = "#fff"; ctx.fillText("â™Ÿ", x, y);
      ctx.strokeStyle="#000"; ctx.lineWidth=1; ctx.strokeText("â™Ÿ",x,y);
    }
  } else { // BLACK PLAYER
    if(imgBlack.complete && imgBlack.naturalHeight !== 0){
      ctx.shadowColor = "rgba(0,0,0,0.5)"; ctx.shadowBlur = 5; ctx.shadowOffsetY = 3;
      ctx.drawImage(imgBlack, x - offset, y - offset - 5, size, size);
      ctx.shadowBlur = 0; ctx.shadowOffsetY = 0;
    } else {
      ctx.font = "50px Arial"; ctx.textAlign="center"; ctx.textBaseline="middle";
      ctx.fillStyle = "#000"; ctx.fillText("â™Ÿ", x, y);
      ctx.strokeStyle="#fff"; ctx.lineWidth=1; ctx.strokeText("â™Ÿ",x,y);
    }
  }
}

function updateTurnUI(){
  const el = document.getElementById("turn-indicator");
  if(turn === "BLUE"){
    el.innerText = "WHITE TURN";
    el.style.borderColor = "#fff";
    el.style.color = "#fff";
  } else {
    el.innerText = "BLACK TURN";
    el.style.borderColor = "#9e9e9e";
    el.style.color = "#9e9e9e";
  }
}

/* ================= LOGIC (UNCHANGED CORE) ================= */

function valid(a,b){
  // Check if target is empty AND connected
  return board[b]==null && L.some(l=>(l[0]==a&&l[1]==b)||(l[1]==a&&l[0]==b));
}

function checkWin(p){
  // Find winning line
  let winLine = W.find(line => {
    if (p==="RED" && line.join()==="0,1,2") return false; // Forbidden base
    if (p==="BLUE"  && line.join()==="6,7,8") return false; // Forbidden base
    return line.every(i => board[i]===p);
  });
  
  if(winLine) {
    winningLine = winLine; // Save for drawing
    return true;
  }
  return false;
}

// Helper for AI (doesn't set global winningLine)
function checkWinSim(simBoard, p){
  return W.some(line => {
    if (p==="RED" && line.join()==="0,1,2") return false;
    if (p==="BLUE"  && line.join()==="6,7,8") return false;
    return line.every(i => simBoard[i]===p);
  });
}

function doMove(a,b){
 let movingPlayer = board[a]; 
 board[a] = null; 
 board[b] = turn;
 playMoveSound();
 
 // Track visual state
 lastMove = {from: a, to: b};
 animState = { active: true, fromIdx: a, toIdx: b, progress: 0, player: movingPlayer };
 
 if(checkWin(turn)){
   animState.active = false; 
   gameActive = false;
   clearInterval(timerInterval);
   draw(); // Redraw to show green glow
   setTimeout(()=>{
     alert((turn=="BLUE"?"WHITE":"BLACK")+" WINS!");
   }, 100);
   return;
 }
 
 turn = turn=="BLUE"?"RED":"BLUE";
 updateTurnUI();
 draw(); 
 
 // AI Trigger
 if(gameActive){
   if(mode === "AI-VS-AI") {
       setTimeout(aiMove, 600);
   } else if(turn=="RED" && mode!=="2P") {
       setTimeout(aiMove, 500);
   }
 }
}

function possibleMoves(p, currentBoard){
 let res=[];
 currentBoard.forEach((v,i)=>{
  if(v==p) L.forEach(l=>{
   let t=l[0]==i?l[1]:l[1]==i?l[0]:null;
   if(t!==null && currentBoard[t]==null) res.push([i,t]);
  });
 });
 return res;
}

/* ================= AI LOGIC (MINIMAX) ================= */

function aiMove(){
 if(!gameActive) return;
 
 let p = turn; 
 let moves = possibleMoves(p, board);
 if(moves.length === 0) return; // No moves (stalemate/loss logic needed? assuming not for now)

 // EASY
 if(mode=="EASY"){
  let m=moves[Math.floor(Math.random()*moves.length)]; 
  doMove(m[0],m[1]); return;
 }
 
 // MEDIUM
 if(mode=="MEDIUM"){
  // Win if can
  for(let m of moves){
   let save=[...board]; board[m[0]]=null; board[m[1]]=p;
   if(checkWinSim(board, p)){board=save; doMove(m[0],m[1]); return;} board=save;
  }
  // Block if must
  let opp = p=="RED"?"BLUE":"RED";
  let opMoves = possibleMoves(opp, board);
  // (Simplified block logic: if opponent can win next, try to intercept? 
  // Minimax handles this better, sticking to original code logic structure roughly)
  
  // Original logic used explicit block check or random
  let m=moves[Math.floor(Math.random()*moves.length)]; 
  doMove(m[0],m[1]); return;
 }

 // HARD & AI-VS-AI (MINIMAX)
 let bestScore = (p === "RED") ? -Infinity : Infinity;
 let bestMove = moves[Math.floor(Math.random()*moves.length)]; 

 moves.forEach(m=>{
  let save=[...board];
  board[m[0]]=null; board[m[1]]=p;
  
  let nextIsMax = (p === "BLUE"); // If current was RED(AI), next is BLUE(Player) -> Minimize
  let s = minimax(nextIsMax, 0, -Infinity, Infinity);
  board=save;

  if (p === "RED") { // Maximize
      if(s > bestScore){ bestScore=s; bestMove=m; }
  } else { // Minimize
      if(s < bestScore){ bestScore=s; bestMove=m; }
  }
 });
 doMove(bestMove[0], bestMove[1]);
}

function minimax(isMax, depth, alpha, beta){
 if(checkWinSim(board, "RED")) return 10 - depth;
 if(checkWinSim(board, "BLUE")) return depth - 10;
 if(depth > 4) return 0; // Depth limit

 let p = isMax ? "RED" : "BLUE";
 let moves = possibleMoves(p, board);
 
 if(isMax){
   let best = -Infinity;
   for(let m of moves){
     let save=[...board];
     board[m[0]]=null; board[m[1]]=p;
     let val = minimax(false, depth+1, alpha, beta);
     board=save;
     best = Math.max(best, val);
     alpha = Math.max(alpha, best);
     if(beta <= alpha) break;
   }
   return best;
 } else {
   let best = Infinity;
   for(let m of moves){
     let save=[...board];
     board[m[0]]=null; board[m[1]]=p;
     let val = minimax(true, depth+1, alpha, beta);
     board=save;
     best = Math.min(best, val);
     beta = Math.min(beta, best);
     if(beta <= alpha) break;
   }
   return best;
 }
}

/* ================= INPUT HANDLING ================= */
c.onclick = e => {
 if(!gameActive) return;
 if(mode === "AI-VS-AI") return; 
 if(turn === "RED" && mode !== "2P") return; // AI Turn
 if(animState.active) return;
 
 let r = c.getBoundingClientRect();
 let x = e.clientX - r.left;
 let y = e.clientY - r.top;
 
 // Find clicked node
 let clickedIdx = -1;
 N.forEach((n,i)=>{
  // Rectangular hit area for tiles
  if(x > n.x - 35 && x < n.x + 35 && y > n.y - 35 && y < n.y + 35){
    clickedIdx = i;
  }
 });

 if(clickedIdx !== -1){
   if(sel === null){
     // Select piece
     if(board[clickedIdx] === turn) sel = clickedIdx;
   } else {
     // Move or Reselect
     if(board[clickedIdx] === turn){
       sel = clickedIdx; // Change selection
     } else if(valid(sel, clickedIdx)){
       doMove(sel, clickedIdx);
       sel = null;
     } else {
       sel = null; // Deselect
     }
   }
   draw();
 }
};

// Init
fullReset();

</script>
</body>
</html>
